# django-migrations-ci
Optimizations to run less migrations on CI

Django migrations are slow because of state recreation for every migration and other internal Django magic.

In the past, I tried to optimize that, but discovered it's a [running issue](https://code.djangoproject.com/ticket/29898).

## Assumptions

1. I want to run my migrations on CI. It is a sanity check, even if they are generated by Django in some cases.
1. I don't have to run migrations all the time. If migrations didn't change, I can reuse them.
1. The solutions probably are CI-specific and database-specific, but it is possible to write code for a generic workflow and snippets to support each CI.

## Idea

### Generate database state from migrations
GitLab CI (the one I have more experience, but I'm sure others have similar features) has caching based on versioned files.

I can cache database state, based on migrations files (and installed dependencies?).

When cache exists, load this database state (restore?) before your tests and run your tests without migrations.

When cache doesn't exist, run migrations and dump the final state for an SQL file.

Dump and restore are database-specific, but possible to handle all Django supported databases.

## How databases for parallel tests are named

Django test framework has a `--parallel N` flag to test with N parallel processes,
naming databases from 1 to N.

* On sqlite3, a `db.sqlite3` generate `db_N.sqlite3` files.
* On PostgreSQL, a `db` generate `test_db_N`.

Pytest `pytest-django` use `pytest-xdist` for parallel support, naming databases
from 0 to N-1.

* On sqlite3, a `db.sqlite3` generate `db.sqlite3_gwN` files.
* On PostgreSQL, a `db` generate `test_db_gwN`.

## Workflow

This is how the "run test" CI job should work.

```
Restore migrateci.sql from CI cache

if migrateci.sql exists on cache:
  Restore migrateci.sql to test database
else:
  Setup test database
  Dump test database to migrateci.sql

Clone the test database to run threaded tests

Save migrateci.sql to CI cache
```

## Cache example on GitHub

```
    steps:
    - uses: actions/cache@v3
      name: Cache migrations
      with:
        path: migrateci-*
        key: ${{ secrets.EXAMPLE_CACHE_PREFIX }}-${{ hashFiles('**/migrations/*.py') }}
    - name: Migrate database
      run: ./manage.py migrateci --parallel $(nproc).
    - name: Test with Django
      run: ./manage.py test --keepdb
```

## Cache example on GitLab

Still have to abstract `psql/pg_dump/pg_restore`, but I expect something like that will work:

```
test_job:
  stage: test
  script:
    - head migrateci-dbtest.sqlite3 || echo 'migrateci-dbtest.sqlite3 does not exist.'
    - ./manage.py migrateci $(nproc)
    - pytest --reuse-db -n $(nproc)
  cache:
    key:
      # GitLab docs say it accepts only two files, but for some reason it works with wildcards too.
      # You can't add more than two lines here.
      files:
        - "requirements.txt"
        - "*/migrations/*.py"
    paths:
      - migrateci-dbtest.sqlite3
 ```
